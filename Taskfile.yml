# Taskfile.yml - EquiDuty Project Tasks
# https://taskfile.dev
#
# Usage:
#   task --list              # List all tasks
#   task deploy:frontend     # Deploy frontend to dev
#   task deploy:api          # Deploy API to dev
#   task deploy:function NAME=processNotificationQueue
#   task tf:plan             # Terraform plan for dev
#
# Environment Override:
#   task deploy:frontend ENV=staging
#   task deploy:api ENV=prod

version: '3'

# =============================================================================
# Variables
# =============================================================================

vars:
  # Default environment (dev, staging, prod)
  ENV: '{{.ENV | default "dev"}}'

  # GCP Configuration
  PROJECT_ID: equiduty-{{.ENV}}
  REGION: europe-west1

  # Service names
  API_SERVICE: '{{.ENV}}-api-service'

  # Paths
  ROOT_DIR:
    sh: pwd
  FRONTEND_DIR: '{{.ROOT_DIR}}/packages/frontend'
  API_DIR: '{{.ROOT_DIR}}/packages/api'
  FUNCTIONS_DIR: '{{.ROOT_DIR}}/packages/functions'
  LANDING_DIR: '{{.ROOT_DIR}}/packages/landing'
  SHARED_DIR: '{{.ROOT_DIR}}/packages/shared'
  TERRAFORM_DIR: '{{.ROOT_DIR}}/terraform'

  # Vite build mode (maps ENV to Vite --mode flag)
  VITE_MODE: '{{if eq .ENV "prod"}}production{{else if eq .ENV "staging"}}staging{{else}}development{{end}}'

# =============================================================================
# Environment Configuration
# =============================================================================

env:
  CLOUDSDK_CORE_PROJECT: '{{.PROJECT_ID}}'

# =============================================================================
# Tasks
# =============================================================================

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  # ===========================================================================
  # Environment Tasks
  # ===========================================================================

  env:
    desc: Show current environment configuration
    silent: true
    cmds:
      - echo "Environment Configuration"
      - echo "========================="
      - echo "ENV={{.ENV}}"
      - echo "PROJECT_ID={{.PROJECT_ID}}"
      - echo "REGION={{.REGION}}"
      - echo "API_SERVICE={{.API_SERVICE}}"

  env:switch:
    desc: Switch Firebase/GCP environment
    cmds:
      - gcloud config set project {{.PROJECT_ID}}
      - firebase use {{.PROJECT_ID}}
      - echo "Switched to {{.ENV}} environment ({{.PROJECT_ID}})"

  # ===========================================================================
  # Version & Release Tasks
  # ===========================================================================

  version:
    desc: Show current app version, latest tag, and shared package version
    silent: true
    vars:
      APP_VERSION:
        sh: cat VERSION 2>/dev/null || echo "unknown"
      LATEST_TAG:
        sh: git tag --sort=-v:refname | head -1 2>/dev/null || echo "none"
      SHARED_VERSION:
        sh: node -p "require('./packages/shared/package.json').version" 2>/dev/null || echo "unknown"
    cmds:
      - echo "App{{":"}} {{.APP_VERSION}} | Tag{{":"}} {{.LATEST_TAG}} | Shared{{":"}} {{.SHARED_VERSION}}"

  version:bump:
    desc: Bump app version (BUMP=patch|minor|major)
    vars:
      BUMP: '{{.BUMP | default "patch"}}'
      CURRENT:
        sh: cat VERSION
    cmds:
      - |
        IFS='.' read -r MAJOR MINOR PATCH <<< "{{.CURRENT}}"
        case "{{.BUMP}}" in
          major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
          minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
          patch) PATCH=$((PATCH + 1)) ;;
          *) echo "Invalid BUMP={{.BUMP}}. Use patch|minor|major"; exit 1 ;;
        esac
        NEW="${MAJOR}.${MINOR}.${PATCH}"
        echo "${NEW}" > VERSION
        echo "Version bumped: {{.CURRENT}} → ${NEW}"

  release:
    desc: "Create a release: bump VERSION, merge develop→main, tag, push (BUMP=patch|minor|major)"
    silent: true
    vars:
      BUMP: '{{.BUMP | default "patch"}}'
    cmds:
      - |
        set -euo pipefail

        # Colors
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        CYAN='\033[0;36m'
        BOLD='\033[1m'
        DIM='\033[2m'
        NC='\033[0m'

        fail() {
          echo ""
          echo -e "${RED}${BOLD}RELEASE BLOCKED${NC}"
          echo -e "${RED}$1${NC}"
          if [ -n "${2:-}" ]; then
            echo -e "${YELLOW}Fix:${NC} $2"
          fi
          echo ""
          exit 1
        }

        echo -e "${BOLD}Pre-flight checks${NC}"
        echo -e "${DIM}─────────────────${NC}"

        # 1. Must be on develop
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        if [ "$BRANCH" != "develop" ]; then
          fail "Must be on 'develop' branch (currently on '${BRANCH}')." \
               "git checkout develop"
        fi
        echo -e "  ${GREEN}✓${NC} On branch develop"

        # 2. Clean working tree (tracked files)
        if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
          echo -e "  ${RED}✗${NC} Working tree dirty"
          echo ""
          echo -e "${DIM}Uncommitted changes:${NC}"
          git status --short | grep -v '^??' | head -15
          echo ""
          fail "Working tree has uncommitted changes." \
               "git stash  OR  git commit your changes first"
        fi

        # 2b. Check for untracked files that matter (ignore common noise)
        UNTRACKED=$(git ls-files --others --exclude-standard | grep -v -E '\.(xcuserstate|DS_Store)$' | head -10 || true)
        if [ -n "$UNTRACKED" ]; then
          echo -e "  ${YELLOW}⚠${NC} Untracked files found:"
          echo "$UNTRACKED" | sed 's/^/      /'
          echo ""
          echo -e "  ${DIM}These won't be included in the release.${NC}"
          echo -e "  ${DIM}If they should be, commit them first. Otherwise, continue.${NC}"
        fi
        echo -e "  ${GREEN}✓${NC} Working tree clean"

        # 3. Fetch latest from origin
        echo -e "  ${DIM}Fetching origin...${NC}"
        git fetch origin --quiet 2>/dev/null || fail "Cannot reach origin." "Check your network connection."

        # 4. develop must be up-to-date with origin/develop
        LOCAL_DEV=$(git rev-parse develop)
        REMOTE_DEV=$(git rev-parse origin/develop 2>/dev/null || echo "none")
        if [ "$REMOTE_DEV" = "none" ]; then
          fail "Cannot find origin/develop." \
               "git fetch origin"
        fi
        AHEAD_DEV=$(git rev-list origin/develop..develop --count)
        BEHIND_DEV=$(git rev-list develop..origin/develop --count)
        if [ "$BEHIND_DEV" != "0" ]; then
          fail "develop is ${BEHIND_DEV} commit(s) behind origin/develop." \
               "git pull origin develop"
        fi
        if [ "$AHEAD_DEV" != "0" ]; then
          echo -e "  ${YELLOW}⚠${NC} develop is ${AHEAD_DEV} commit(s) ahead of origin (will be pushed)"
        else
          echo -e "  ${GREEN}✓${NC} develop is up-to-date with origin"
        fi

        # 5. main branch must exist locally
        if ! git rev-parse --verify main >/dev/null 2>&1; then
          fail "Local 'main' branch not found." \
               "git checkout main && git pull origin main && git checkout develop"
        fi

        # 6. main must be up-to-date with origin/main
        LOCAL_MAIN=$(git rev-parse main)
        REMOTE_MAIN=$(git rev-parse origin/main 2>/dev/null || echo "none")
        if [ "$REMOTE_MAIN" = "none" ]; then
          fail "Cannot find origin/main." \
               "git fetch origin"
        fi
        BEHIND_MAIN=$(git rev-list main..origin/main --count)
        if [ "$BEHIND_MAIN" != "0" ]; then
          fail "Local main is ${BEHIND_MAIN} commit(s) behind origin/main." \
               "git checkout main && git pull origin main && git checkout develop"
        fi
        echo -e "  ${GREEN}✓${NC} main is up-to-date with origin"

        # 7. main must be ancestor of develop (fast-forward possible)
        if ! git merge-base --is-ancestor main develop; then
          fail "main has diverged from develop (fast-forward not possible)." \
               "git checkout develop && git merge main  OR  rebase"
        fi
        echo -e "  ${GREEN}✓${NC} Fast-forward merge possible"

        # 8. Calculate new version
        CURRENT=$(cat VERSION)
        IFS='.' read -r MAJOR MINOR PATCH <<< "${CURRENT}"
        case "{{.BUMP}}" in
          major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
          minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
          patch) PATCH=$((PATCH + 1)) ;;
          *) fail "Invalid BUMP={{.BUMP}}." "Use BUMP=patch|minor|major" ;;
        esac
        NEW="${MAJOR}.${MINOR}.${PATCH}"

        # 9. Check tag doesn't already exist
        if git rev-parse "v${NEW}" >/dev/null 2>&1; then
          fail "Tag v${NEW} already exists." \
               "Use a different BUMP level or delete the tag first."
        fi
        echo -e "  ${GREEN}✓${NC} Tag v${NEW} is available"

        # 10. Show what will be released
        COMMITS_AHEAD=$(git rev-list main..develop --count)
        echo ""
        echo -e "${BOLD}Release summary${NC}"
        echo -e "${DIM}───────────────${NC}"
        echo -e "  Version:  ${CYAN}v${CURRENT}${NC} → ${GREEN}${BOLD}v${NEW}${NC} ({{.BUMP}})"
        echo -e "  Commits:  ${COMMITS_AHEAD} commit(s) since last release"
        if [ "$COMMITS_AHEAD" -gt 0 ]; then
          echo -e "  ${DIM}Changes:${NC}"
          git log main..develop --oneline --no-decorate | head -15 | sed 's/^/    /'
          if [ "$COMMITS_AHEAD" -gt 15 ]; then
            echo -e "    ${DIM}... and $((COMMITS_AHEAD - 15)) more${NC}"
          fi
        fi
        echo ""

        # 11. Confirm
        if [ -t 0 ]; then
          echo -ne "${YELLOW}Proceed with release v${NEW}? [y/N]${NC} "
          read -r CONFIRM
          if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
            echo "Release cancelled."
            exit 1
          fi
          echo ""
        fi

        # === Execute release ===

        echo -e "${BOLD}Releasing v${NEW}${NC}"
        echo -e "${DIM}─────────────${NC}"

        # Bump VERSION
        echo "${NEW}" > VERSION
        git add VERSION
        git commit -m "release: v${NEW}" --quiet
        echo -e "  ${GREEN}✓${NC} Committed VERSION bump on develop"

        # Merge develop → main
        git checkout main --quiet
        git merge develop --ff-only --quiet
        echo -e "  ${GREEN}✓${NC} Merged develop → main (fast-forward)"

        # Tag
        git tag -a "v${NEW}" -m "Release v${NEW}"
        echo -e "  ${GREEN}✓${NC} Tagged v${NEW}"

        # Push everything
        git push origin main --quiet
        git push origin "v${NEW}" --quiet
        git checkout develop --quiet
        git push origin develop --quiet
        echo -e "  ${GREEN}✓${NC} Pushed main, tag, and develop"

        echo ""
        echo -e "${GREEN}${BOLD}Released v${NEW}${NC}"
        echo ""
        echo -e "  Deploy staging:  ${CYAN}task deploy:api ENV=staging TAG=v${NEW}${NC}"
        echo -e "  Deploy prod:     ${CYAN}task deploy:api ENV=prod TAG=v${NEW}${NC}"
        echo ""

  release:tag-only:
    desc: Create a tag from current VERSION without merging (for manual merge workflows)
    cmds:
      - |
        set -euo pipefail
        VERSION=$(cat VERSION)
        TAG="v${VERSION}"

        if git rev-parse "${TAG}" >/dev/null 2>&1; then
          echo "Tag ${TAG} already exists."
          exit 1
        fi

        git tag -a "${TAG}" -m "Release ${TAG}"
        git push origin "${TAG}"
        echo "Created and pushed tag ${TAG}"

  # ===========================================================================
  # Deploy Safety Gates
  # ===========================================================================

  deploy:gate:
    desc: Validate branch/tag before deploy (internal)
    internal: true
    cmds:
      - bash ./scripts/check-deploy-branch.sh {{.ENV}} {{.TAG | default ""}}
    status:
      - '[ "{{.ENV}}" = "dev" ]'

  deploy:tag:
    desc: Deploy from a specific git tag (TAG=v0.x.y ENV=staging|prod DEPLOY_TASK=deploy:api)
    requires:
      vars: [TAG, ENV, DEPLOY_TASK]
    vars:
      PREVIOUS_REF:
        sh: git rev-parse --abbrev-ref HEAD 2>/dev/null || git rev-parse --short HEAD
    cmds:
      - echo "Checking out tag {{.TAG}}..."
      - git checkout {{.TAG}} --quiet
      - defer: |
          echo "Restoring previous ref ({{.PREVIOUS_REF}})..."
          git checkout {{.PREVIOUS_REF}} --quiet
      - task: '{{.DEPLOY_TASK}}'
        vars:
          ENV: '{{.ENV}}'
          TAG: '{{.TAG}}'

  # ===========================================================================
  # Deploy Tasks
  # ===========================================================================

  deploy:frontend:
    desc: Build and deploy React app to Firebase Hosting (app target)
    dir: '{{.FRONTEND_DIR}}'
    deps: [deploy:gate, config:validate-frontend-env]
    cmds:
      - echo "Building frontend for {{.ENV}} (mode={{.VITE_MODE}})..."
      - npx vite build --mode {{.VITE_MODE}} --outDir {{.ROOT_DIR}}/.build/frontend-{{.ENV}} --emptyOutDir
      - rm -rf dist && cp -r {{.ROOT_DIR}}/.build/frontend-{{.ENV}} dist
      - echo "Deploying app to Firebase Hosting..."
      - firebase deploy --only hosting:app --project {{.PROJECT_ID}}
      - echo "Frontend app deployed to {{.ENV}}"

  deploy:landing:
    desc: Build and deploy Astro landing site to Firebase Hosting (landing target)
    dir: '{{.LANDING_DIR}}'
    deps: [deploy:gate]
    cmds:
      - echo "Building landing site for {{.ENV}} (mode={{.VITE_MODE}})..."
      - npx astro build --mode {{.VITE_MODE}} --outDir {{.ROOT_DIR}}/.build/landing-{{.ENV}}
      - rm -rf dist && cp -r {{.ROOT_DIR}}/.build/landing-{{.ENV}} dist
      - echo "Deploying landing to Firebase Hosting..."
      - cd {{.ROOT_DIR}} && firebase deploy --only hosting:landing --project {{.PROJECT_ID}}
      - echo "Landing site deployed to {{.ENV}}"

  deploy:frontend:all:
    desc: Deploy both landing and app sites to Firebase Hosting
    deps: [deploy:gate]
    cmds:
      - task: deploy:landing
      - task: deploy:frontend
      - echo "✅ Complete frontend deployment (landing + app) to {{.ENV}} complete"

  deploy:api:
    desc: Deploy API to Cloud Run
    deps: [deploy:gate]
    vars:
      IMAGE: gcr.io/{{.PROJECT_ID}}/api-service:{{.TAG | default "latest"}}
      STAGE_DIR: '{{.ROOT_DIR}}/.build/api-{{.ENV}}'
    cmds:
      - bash scripts/prepare-api-deploy.sh {{.ENV}}
      - defer: bash scripts/cleanup-api-deploy.sh {{.ENV}}
      - echo "Building API container..."
      - gcloud builds submit --tag {{.IMAGE}} --project {{.PROJECT_ID}} {{.STAGE_DIR}}
      - echo "Deploying to Cloud Run..."
      - gcloud run deploy {{.API_SERVICE}} --image {{.IMAGE}} --region {{.REGION}} --platform managed --allow-unauthenticated --project {{.PROJECT_ID}}
      - echo "API deployed to {{.ENV}}"

  deploy:api:source:
    desc: Deploy API directly from source (no container build)
    dir: '{{.API_DIR}}'
    deps: [deploy:gate]
    cmds:
      - echo "Deploying API from source..."
      - gcloud run deploy {{.API_SERVICE}} --source . --region {{.REGION}} --platform managed --allow-unauthenticated --project {{.PROJECT_ID}}
      - echo "API deployed to {{.ENV}}"

  deploy:functions:
    desc: Build, upload, and deploy Cloud Functions via Terraform
    deps: [deploy:gate]
    cmds:
      - bash ./scripts/build-functions-source.sh {{.ENV}}
      - echo "Deploying functions via Terraform..."
      - cd {{.TERRAFORM_DIR}}/environments/{{.ENV}} && terraform apply -auto-approve -input=false -target=module.cloud_functions
      - echo "All functions deployed to {{.ENV}}"

  deploy:firestore:rules:
    desc: Deploy Firestore security rules
    deps: [deploy:gate]
    cmds:
      - echo "Deploying Firestore rules..."
      - firebase deploy --only firestore:rules --project {{.PROJECT_ID}}
      - echo "Firestore rules deployed to {{.ENV}}"

  deploy:firestore:indexes:
    desc: Deploy Firestore indexes
    deps: [deploy:gate]
    cmds:
      - echo "Deploying Firestore indexes..."
      - firebase deploy --only firestore:indexes --project {{.PROJECT_ID}}
      - echo "Firestore indexes deployed to {{.ENV}}"

  deploy:storage:rules:
    desc: Deploy Storage security rules
    deps: [deploy:gate]
    cmds:
      - echo "Deploying Storage rules..."
      - firebase deploy --only storage --project {{.PROJECT_ID}}
      - echo "Storage rules deployed to {{.ENV}}"

  deploy:all:
    desc: Deploy everything (landing, frontend, API, functions, rules)
    cmds:
      - task: deploy:firestore:rules
      - task: deploy:firestore:indexes
      - task: deploy:storage:rules
      - task: deploy:functions
      - task: deploy:api
      - task: deploy:landing
      - task: deploy:frontend
      - echo "Full deployment to {{.ENV}} complete!"

  deploy:shared:publish:
    desc: Publish shared package to Artifact Registry (VERSION_BUMP=patch|minor|major)
    dir: '{{.SHARED_DIR}}'
    vars:
      VERSION_BUMP: '{{.VERSION_BUMP | default "patch"}}'
    cmds:
      - echo "Refreshing Artifact Registry credentials..."
      - npx google-artifactregistry-auth
      - echo "Building shared package..."
      - npm run build
      - echo "Bumping version ({{.VERSION_BUMP}})..."
      - npm version {{.VERSION_BUMP}} --no-git-tag-version
      - echo "Publishing to Google Artifact Registry..."
      - npm publish
      - echo "Shared package published to Artifact Registry"

  # ===========================================================================
  # Terraform Tasks
  # ===========================================================================

  tf:init:
    desc: Initialize Terraform for environment
    dir: '{{.TERRAFORM_DIR}}/environments/{{.ENV}}'
    cmds:
      - terraform init

  tf:plan:
    desc: Plan Terraform changes
    dir: '{{.TERRAFORM_DIR}}/environments/{{.ENV}}'
    cmds:
      - terraform plan

  tf:apply:
    desc: Apply Terraform changes
    dir: '{{.TERRAFORM_DIR}}/environments/{{.ENV}}'
    cmds:
      - terraform apply

  tf:apply:auto:
    desc: Apply Terraform changes (auto-approve)
    dir: '{{.TERRAFORM_DIR}}/environments/{{.ENV}}'
    cmds:
      - terraform apply -auto-approve

  tf:destroy:
    desc: Destroy Terraform resources (DANGEROUS)
    dir: '{{.TERRAFORM_DIR}}/environments/{{.ENV}}'
    prompt: This will DESTROY all resources in {{.ENV}}. Are you sure?
    cmds:
      - terraform destroy

  tf:state:list:
    desc: List Terraform state
    dir: '{{.TERRAFORM_DIR}}/environments/{{.ENV}}'
    cmds:
      - terraform state list

  tf:output:
    desc: Show Terraform outputs
    dir: '{{.TERRAFORM_DIR}}/environments/{{.ENV}}'
    cmds:
      - terraform output

  tf:validate:
    desc: Validate Terraform configuration
    dir: '{{.TERRAFORM_DIR}}/environments/{{.ENV}}'
    cmds:
      - terraform validate

  tf:fmt:
    desc: Format Terraform files
    dir: '{{.TERRAFORM_DIR}}'
    cmds:
      - terraform fmt -recursive

  tf:init-backend:
    desc: Initialize Terraform state bucket
    dir: '{{.TERRAFORM_DIR}}'
    cmds:
      - ./scripts/init-backend.sh {{.PROJECT_ID}}

  tf:import:
    desc: Import existing resources
    dir: '{{.TERRAFORM_DIR}}'
    cmds:
      - ./scripts/import-existing.sh {{.PROJECT_ID}} {{.ENV}}

  # ===========================================================================
  # Development Tasks
  # ===========================================================================

  dev:landing:
    desc: Start landing site dev server
    dir: '{{.LANDING_DIR}}'
    cmds:
      - npm run dev

  dev:frontend:
    desc: Start frontend dev server
    dir: '{{.FRONTEND_DIR}}'
    cmds:
      - npm run dev

  dev:api:
    desc: Start API dev server
    dir: '{{.API_DIR}}'
    cmds:
      - npm run dev

  dev:emulators:
    desc: Start Firebase emulators
    cmds:
      - firebase emulators:start --import=./.firebase-data --export-on-exit=./.firebase-data

  dev:emulators:export:
    desc: Export emulator data
    cmds:
      - firebase emulators:export ./.firebase-data --force
      - echo "Emulator data exported to .firebase-data/"

  dev:emulators:clear:
    desc: Clear emulator data
    cmds:
      - rm -rf ./.firebase-data
      - echo "Emulator data cleared"

  # ===========================================================================
  # Build Tasks
  # ===========================================================================

  build:
    desc: Build all packages
    cmds:
      - task: build:shared
      - task: build:landing
      - task: build:frontend
      - task: build:api
      - task: build:functions

  build:landing:
    desc: Build landing site
    dir: '{{.LANDING_DIR}}'
    cmds:
      - npm run build

  build:frontend:
    desc: Build frontend
    dir: '{{.FRONTEND_DIR}}'
    cmds:
      - npm run build

  build:api:
    desc: Build API
    dir: '{{.API_DIR}}'
    cmds:
      - npm run build

  build:functions:
    desc: Build functions
    dir: '{{.FUNCTIONS_DIR}}'
    cmds:
      - npm run build

  build:shared:
    desc: Build shared package
    dir: '{{.SHARED_DIR}}'
    cmds:
      - npm run build

  # ===========================================================================
  # Test Tasks
  # ===========================================================================

  test:
    desc: Run all tests
    cmds:
      - task: test:frontend
      - task: test:api
      - task: test:functions

  test:frontend:
    desc: Run frontend tests
    dir: '{{.FRONTEND_DIR}}'
    cmds:
      - npm run test

  test:api:
    desc: Run API tests
    dir: '{{.API_DIR}}'
    cmds:
      - npm run test

  test:functions:
    desc: Run functions tests
    dir: '{{.FUNCTIONS_DIR}}'
    cmds:
      - npm run test

  test:e2e:
    desc: Run E2E tests with Playwright
    cmds:
      - npx playwright test

  test:e2e:ui:
    desc: Run E2E tests with Playwright UI
    cmds:
      - npx playwright test --ui

  # ===========================================================================
  # Lint & Format Tasks
  # ===========================================================================

  lint:
    desc: Lint all packages
    cmds:
      - npm run lint --workspaces --if-present

  format:
    desc: Format code with Prettier
    cmds:
      - npx prettier --write "packages/**/*.{ts,tsx,js,jsx,json,css,md}"

  typecheck:
    desc: Run TypeScript type checking
    cmds:
      - npm run typecheck --workspaces --if-present

  # ===========================================================================
  # Install Tasks
  # ===========================================================================

  install:
    desc: Install all dependencies
    cmds:
      - npm install
      - npm install --workspaces

  install:clean:
    desc: Clean install (remove node_modules first)
    cmds:
      - rm -rf node_modules packages/*/node_modules
      - npm install
      - npm install --workspaces

  # ===========================================================================
  # Secrets Tasks
  # ===========================================================================

  secrets:list:
    desc: List all secrets
    cmds:
      - gcloud secrets list --project {{.PROJECT_ID}}

  secrets:set:
    desc: Set a secret value (SECRET=name VALUE=value)
    requires:
      vars: [SECRET, VALUE]
    cmds:
      - echo -n "{{.VALUE}}" | gcloud secrets versions add {{.ENV}}-{{.SECRET}} --data-file=- --project {{.PROJECT_ID}}
      - echo "Secret {{.ENV}}-{{.SECRET}} updated"

  secrets:set:file:
    desc: Set a secret from file (SECRET=name FILE=path)
    requires:
      vars: [SECRET, FILE]
    cmds:
      - gcloud secrets versions add {{.ENV}}-{{.SECRET}} --data-file={{.FILE}} --project {{.PROJECT_ID}}
      - echo "Secret {{.ENV}}-{{.SECRET}} updated from file"

  secrets:get:
    desc: Get a secret value (SECRET=name)
    requires:
      vars: [SECRET]
    cmds:
      - gcloud secrets versions access latest --secret={{.ENV}}-{{.SECRET}} --project {{.PROJECT_ID}}

  # ===========================================================================
  # Logs & Monitoring Tasks
  # ===========================================================================

  logs:api:
    desc: View Cloud Run API logs
    vars:
      LIMIT: '{{.LIMIT | default "50"}}'
    cmds:
      - gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name={{.API_SERVICE}}" --limit={{.LIMIT}} --project {{.PROJECT_ID}} --format="table(timestamp,severity,textPayload)"

  logs:functions:
    desc: View Cloud Functions logs
    vars:
      LIMIT: '{{.LIMIT | default "50"}}'
    cmds:
      - gcloud logging read "resource.type=cloud_function" --limit={{.LIMIT}} --project {{.PROJECT_ID}} --format="table(timestamp,severity,resource.labels.function_name,textPayload)"

  logs:function:
    desc: View logs for specific function (NAME=functionName)
    requires:
      vars: [NAME]
    vars:
      LIMIT: '{{.LIMIT | default "50"}}'
    cmds:
      - gcloud logging read "resource.type=cloud_function AND resource.labels.function_name={{.NAME}}" --limit={{.LIMIT}} --project {{.PROJECT_ID}} --format="table(timestamp,severity,textPayload)"

  logs:tail:api:
    desc: Tail Cloud Run API logs (live)
    cmds:
      - gcloud logging tail "resource.type=cloud_run_revision AND resource.labels.service_name={{.API_SERVICE}}" --project {{.PROJECT_ID}}

  # ===========================================================================
  # Cloud Run Tasks
  # ===========================================================================

  run:describe:
    desc: Describe Cloud Run service
    cmds:
      - gcloud run services describe {{.API_SERVICE}} --region {{.REGION}} --project {{.PROJECT_ID}}

  run:url:
    desc: Get Cloud Run service URL
    cmds:
      - gcloud run services describe {{.API_SERVICE}} --region {{.REGION}} --project {{.PROJECT_ID}} --format="value(status.url)"

  run:revisions:
    desc: List Cloud Run revisions
    cmds:
      - gcloud run revisions list --service {{.API_SERVICE}} --region {{.REGION}} --project {{.PROJECT_ID}}

  # ===========================================================================
  # Scheduler Tasks
  # ===========================================================================

  scheduler:list:
    desc: List Cloud Scheduler jobs
    cmds:
      - gcloud scheduler jobs list --location {{.REGION}} --project {{.PROJECT_ID}}

  scheduler:run:
    desc: Manually trigger a scheduler job (JOB=job-name)
    requires:
      vars: [JOB]
    cmds:
      - gcloud scheduler jobs run {{.JOB}} --location {{.REGION}} --project {{.PROJECT_ID}}
      - echo "Triggered job {{.JOB}}"

  scheduler:pause:
    desc: Pause a scheduler job (JOB=job-name)
    requires:
      vars: [JOB]
    cmds:
      - gcloud scheduler jobs pause {{.JOB}} --location {{.REGION}} --project {{.PROJECT_ID}}
      - echo "Paused job {{.JOB}}"

  scheduler:resume:
    desc: Resume a scheduler job (JOB=job-name)
    requires:
      vars: [JOB]
    cmds:
      - gcloud scheduler jobs resume {{.JOB}} --location {{.REGION}} --project {{.PROJECT_ID}}
      - echo "Resumed job {{.JOB}}"

  # ===========================================================================
  # Database Tasks
  # ===========================================================================

  db:export:
    desc: Export Firestore data
    vars:
      BUCKET: '{{.PROJECT_ID}}-backups'
      TIMESTAMP:
        sh: date +%Y%m%d-%H%M%S
    cmds:
      - gcloud firestore export gs://{{.BUCKET}}/firestore/{{.TIMESTAMP}} --project {{.PROJECT_ID}}
      - echo "Firestore exported to gs://{{.BUCKET}}/firestore/{{.TIMESTAMP}}"

  db:import:
    desc: Import Firestore data (BACKUP=gs://bucket/path)
    requires:
      vars: [BACKUP]
    prompt: This will OVERWRITE data in {{.ENV}}. Are you sure?
    cmds:
      - gcloud firestore import {{.BACKUP}} --project {{.PROJECT_ID}}

  db:seed:
    desc: Seed system data (vaccination rules) into Firestore
    deps: [env:switch]
    cmds:
      - echo "Seeding system data into {{.ENV}} ({{.PROJECT_ID}})..."
      - npx tsx packages/api/src/scripts/seedVaccinationRules.ts {{.ENV}}
      - echo "Seed complete for {{.ENV}}"

  # ===========================================================================
  # Config Tasks (Environment Validation)
  # ===========================================================================

  config:validate-frontend-env:
    desc: Validate frontend env file API URL is reachable
    internal: true
    cmds:
      - |
        if [ "{{.VITE_MODE}}" = "development" ]; then
          echo "ℹ️  Dev environment uses local .env — skipping API URL validation."
          exit 0
        fi
        ENV_FILE="{{.FRONTEND_DIR}}/.env.{{.VITE_MODE}}"
        if [ ! -f "${ENV_FILE}" ]; then
          echo "❌ Missing env file: ${ENV_FILE}"
          echo "   Create it with the correct VITE_* variables for {{.ENV}}."
          exit 1
        fi
        API_URL=$(grep "^VITE_API_URL=" "${ENV_FILE}" | cut -d'=' -f2)
        if [ -z "${API_URL}" ]; then
          echo "❌ VITE_API_URL not set in ${ENV_FILE}"
          exit 1
        fi
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/health" --max-time 10 2>/dev/null)
        if [ "$HTTP_CODE" != "200" ]; then
          echo "⚠️  API URL ${API_URL} returned HTTP ${HTTP_CODE}"
          echo "   The API URL in .env.{{.VITE_MODE}} may have changed."
          echo "   Verify the Cloud Run URL: task run:url ENV={{.ENV}}"
          exit 1
        fi
        echo "✅ API URL verified: ${API_URL} (HTTP ${HTTP_CODE})"

  config:show-api-url:
    desc: Show the current Cloud Run API URL
    cmds:
      - |
        echo "Cloud Run Service: {{.API_SERVICE}}"
        echo "API URL: $(gcloud run services describe {{.API_SERVICE}} --region {{.REGION}} --project {{.PROJECT_ID}} --format='value(status.url)' 2>/dev/null || echo 'Not deployed')"

  # ===========================================================================
  # Utility Tasks
  # ===========================================================================

  clean:
    desc: Clean build artifacts
    cmds:
      - rm -rf .build
      - rm -rf packages/landing/dist
      - rm -rf packages/frontend/dist
      - rm -rf packages/api/dist
      - rm -rf packages/functions/lib
      - rm -rf packages/shared/dist
      - echo "Build artifacts cleaned"

  info:
    desc: Show project information
    cmds:
      - task: env
      - echo ""
      - echo "Tool versions:"
      - node --version
      - npm --version
      - firebase --version
      - gcloud --version | head -1
      - terraform --version | head -1
